<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Vue实例生命周期函数</title>
    <script src="../../vue.js"></script>
</head>
<body>
<div id="app"></div>
<script>
    var vm = new Vue({
        el:'#app',
        data:{
            test:'template option'
        },
        template:'<div>{{test}}</div>',
        beforeCreate:function () {
            // 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。

            console.log('beforCreate')
        },
        created:function () {
            // 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。

            console.log('created')
        },
        beforeMount:function () {
            // 在挂载开始之前被调用：相关的 render 函数首次被调用

            console.log('beforeMount')
            console.log(this.$el);
        },
        mounted:function () {
            // el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。

            console.log('mounted')
            console.log(this.$el);

            this.$data.test = '我改变了test'
            // beforeUpdate   updated方法


        },
        beforeDestroy:function () {
            // 实例销毁之前调用。在这一步，实例仍然完全可用。

            console.log('beforeDestrory')
        },
        destroyed:function () {
            // ue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。

            console.log('destroyed')
        },
        beforeUpdate:function () {
            // 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。

            console.log('boforeUpdate')
        },
        updated:function () {
            // 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。
            // 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。


            console.log('updated')
            this.$destroy();
            // 完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。
            // 触发 beforeDestroy 和 destroyed 的钩子。
        }
    })
</script>
</body>
</html>